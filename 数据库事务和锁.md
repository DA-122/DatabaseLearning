# 数据库事务和锁机制

## 一、数据库事务
**事务是数据库管理系统(DBMS)执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。**

### 1.事务的四大特性:
事务包含四大特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）(ACID)。

* **原子性（Atomicity）** 原子性是指对数据库的一系列操作，<u>要么全部成功，要么全部失败</u>，不可能出现部分成功的情况。以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的。
* **一致性（Consistency）** 一致性是指<u>数据库的完整性约束没有被破坏</u>，在事务执行前后都是合法的数据状态。这里的一致可以表示数据库自身的约束没有被破坏，比如某些字段的唯一性约束、字段长度约束等等；还可以表示各种实际场景下的业务约束，比如上面转账操作，一个账户减少的金额和另一个账户增加的金额一定是一样的。
* **隔离性（Isolation）** 隔离性指的是<u>多个事务彼此之间是完全隔离、互不干扰的</u>。隔离性的最终目的也是为了保证一致性。
* **持久性（Durability）** 持久性是指<u>只要事务提交成功，那么对数据库做的修改就被永久保存下来了</u>，不可能因为任何原因再回到原来的状态。

### 2.事务的状态
* **活动的（active）** 当事务对应的数据库操作正在执行过程中，则该事务处于活动状态。
* **部分提交的（partially committed）** 当事务中的最后一个操作执行完成，但还未将变更刷新到磁盘时，则该事务处于部分提交状态。
* **失败的（failed）** 当事务处于活动或者部分提交状态时，由于某些错误导致事务无法继续执行，则事务处于失败状态。
* **中止的（aborted）** 当事务处于失败状态，且回滚操作执行完毕，数据恢复到事务执行之前的状态时，则该事务处于中止状态。
* **提交的（committed）** 当事务处于部分提交状态，并且将修改过的数据都同步到磁盘之后，此时该事务处于提交状态。
![事务状态](./Image/事务状态.jpg#pic_center "事务状态转化")
****
## 二、数据库锁
### 1.操作划分
* **共享锁（读锁 S锁）** 多个事务对同一数据共享一把锁(读锁)，事务可以对数据进行读操作，不可以进行写操作。
* **排他锁（写锁 X锁）** 事务A对一行数据加排他锁(写锁)后，只有事务A能读和写该数据，其他事务不能在该数据上加锁，既不能读，也不能写。
### 2.粒度划分
* **行锁** 锁一行或多行记录。当其他事务访问数据库同一张表时，被锁定的记录不可以访问，其他的记录都可以访问。
* **表锁** 锁一整张表，当事务A锁定一张表，其他事物不能对该表进行任何操作，只有当当前表锁被释放后才能进行操作。
### 3.模式划分
* **乐观锁** 对于并发冲突保持乐观，操作数据时不会对操作数据加锁，只有当数据提交时才会验证数据是否存在并发冲突（版本号对比机制/CAS算法）。乐观锁适用于多读场景（冲突少）。
* **悲观锁** 基于一种悲观态度来防止一切的并发冲突，只要操作数据就加锁（排他锁），数据操作后释放锁。悲观锁适用于多写场景（冲突多）
### 4.MySql中的锁

****
## 三、并发事务与隔离级别
### 1，并发事务问题
* **脏写** 
* **脏读**
* **不可重复读**
* **幻读**

### 2. 隔离级别
隔离级别指的是，当存在多个事务并发操作相同的数据时，事物之间的相互影响的要求标准。<u>隔离级别是用来解决事务并发带来的问题的，而数据库的锁机制是为了构建这些隔离级别</u>。

数据库事务是增删改查(Insert,Delete,Update,Select)操作的集合，其中Select是读操作，Insert,Update,Delete都是写操作，因此事务并发就是读写并发。

    所有事务单元之间并发关系就是读写、写读、读读、写写四种状态的组合
* **序列化(Serializable)** 
    可串行化是最高等级的隔离级别，事务读写相互阻塞(直接加表级读锁)，所有事务按照次序依次执行，不存在读写并发。
    可串行化不存在脏读、不可重复读、幻读问题，具有最高的安全性，但是性能最差，一般不会用这种隔离级别。
* **可重复读(Repeated Read)**
    可重复读实现了读读并行（事务对数据加读锁，其他事务只能读，不能写），
    
    假设事务A给目标数据加了读锁，其他事务可以读该数据，但不能改该数据，<u>保证了事务A在事务开始时读到的数据内容总是不变的</u>。但是可重复读只给目标数据加读锁，无法保证锁住其他事务对该数据同表的操作(insert操作)，仍然存在幻读问题。

* **读已提交(Read Commited)**
    读已提交实现了读读并行，读写并行，写读、写写串行化进行。(事务读数据时加读锁，其他事务既可以读，也可以写(取消读锁))

    假设事务A对目标数据进行读操作，然后事务B对目标数据进行写操作，读写并行，此时事务A<u>取消读锁</u>，允许事务B写操作，就会导致事务A在事务B写之前和写之后读到的数据不一致。因此存在幻读、不可重复读问题。
* **读未提交(Read Uncommited)**
    读未提交是最低等级的隔离级别，实现了读读并行、写读并行、读写并行三种并发事务。事务不加读锁，只加写锁。

    读未提交只有写写串行化，<u>由于不加读锁，所以读的时候会读到没有完成提交的写数据</u>，如果因为一些错误，导致未提交的写操作回滚，就会读到错误数据，因此存在脏读问题。

四种隔离级别区别在于读锁的使用以及锁的粒度，由于都加写锁，实现了基本的写写并行操作，因此都不存在脏写问题。
### 3.三阶段协议（读未提交、读已提交、可重复读隔离级别具体的锁实现）
* 一级封锁协议：事务在修改数据之前必须先对其加写锁，直到事务结束才释放。
    
    可以解决脏写问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）

* 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，<u>读完后释放</u>。

    可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法读取未提交数据，避免了读取脏数据）

* 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，<u>直到事务结束才能释放</u>。

    可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）。

### 4.两段锁协议（序列化具体的实现）
所有的事务必须分两个阶段对数据项加锁和解锁。即事务分两个阶段，第一个阶段是获得锁。事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是释放锁，事务可以释放任何数据项上的任何类型的锁，但不能申请。

第一阶段是获得封锁的阶段，称为扩展阶段：其实也就是该阶段可以进入加锁操作，在对任何数据进行读操作之前要申请获得S锁，在进行写操作之前要申请并获得X锁，加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。就是加锁后就不能解锁了。

第二阶段是释放封锁的阶段，称为收缩阶段：当事务释放一个封锁后，事务进入封锁阶段，在该阶段只能进行解锁而不能再进行加锁操作。

### 5.MySql是如何实现隔离级别的

****
## 四.MySql MVCC
MVCC多版本并发控制。对于读写并发，一般需要通过数据加锁的方式来解决，但是这样会影响并发效率，MVCC就是在读写并发存在的情况下。不加锁实现非阻塞并发读，降低开销，提高数据库并发性能。MVCC只在Read Commited和 Repeatable read两种隔离级别下工作。 

### 定义
* **当前读** ：读取的数据是最新版本，读取数据时还要保证其他并发事务不会修改当前的数据，当前读会对读取的记录加锁。

    `select …… lock in share mode（共享锁）`

    `select …… for update | update | insert | delete（排他锁）`
* **快照读** ：每一次修改数据，都会在 undo log 中存有快照记录，这里的快照，就是读取undo log中的某一版本的快照。这种方式的优点是可以不用加锁就可以读取到数据，缺点是读取到的数据可能不是最新的版本。一般的查询都是快照读。
    
    `select * from t_user where id=1;`
* **redo log** 记录数据库数据操作在物理层面的修改，
* **undo log** 用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。

### 实现原理