# 数据库事务和锁机制

## 一、数据库事务
**事务是数据库管理系统(DBMS)执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。**

### 1.事务的四大特性:
[参考资料 事务四大特性与实现原理](https://www.cnblogs.com/kismetv/p/10331633.html)

事务包含四大特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）(ACID)。

* **原子性（Atomicity）** 原子性是指对数据库的一系列操作，<u>要么全部成功，要么全部失败</u>，不可能出现部分成功的情况。以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的（通过undo log 保证）。
* **一致性（Consistency）** 一致性是指<u>数据库的完整性约束没有被破坏</u>，在事务执行前后都是合法的数据状态。这里的一致可以表示数据库自身的约束没有被破坏，比如某些字段的唯一性约束、字段长度约束等等；还可以表示各种实际场景下的业务约束，比如上面转账操作，一个账户减少的金额和另一个账户增加的金额一定是一样的。
* **隔离性（Isolation）** 隔离性指的是<u>多个事务彼此之间是完全隔离、互不干扰的</u>。隔离性的最终目的也是为了保证一致性 (通过隔离级别保证，隔离级别通过MVCC实现)。
* **持久性（Durability）** 持久性是指<u>只要事务提交成功，那么对数据库做的修改就被永久保存下来了</u>，不可能因为任何原因再回到原来的状态 (通过redo log 保证)。

### 2.事务的状态
* **活动的（active）** 当事务对应的数据库操作正在执行过程中，则该事务处于活动状态。
* **部分提交的（partially committed）** 当事务中的最后一个操作执行完成，但还未将变更刷新到磁盘时，则该事务处于部分提交状态。
* **失败的（failed）** 当事务处于活动或者部分提交状态时，由于某些错误导致事务无法继续执行，则事务处于失败状态。
* **中止的（aborted）** 当事务处于失败状态，且回滚操作执行完毕，数据恢复到事务执行之前的状态时，则该事务处于中止状态。
* **提交的（committed）** 当事务处于部分提交状态，并且将修改过的数据都同步到磁盘之后，此时该事务处于提交状态。
![事务状态](./Image/事务状态.jpg#pic_center "事务状态转化")
****
## 二、数据库锁
### 1.操作划分
* **共享锁（读锁 S锁）** 多个事务对同一数据共享一把锁(读锁)，事务可以对数据进行读操作，不可以进行写操作。
* **排他锁（写锁 X锁）** 事务A对一行数据加排他锁(写锁)后，只有事务A能读和写该数据，其他事务不能在该数据上加锁，既不能读，也不能写。
### 2.粒度划分
* **行锁** 锁一行或多行记录。当其他事务访问数据库同一张表时，被锁定的记录不可以访问，其他的记录都可以访问。
* **表锁** 锁一整张表，当事务A锁定一张表，其他事物不能对该表进行任何操作，只有当当前表锁被释放后才能进行操作。
### 3.模式划分
* **乐观锁** 对于并发冲突保持乐观，操作数据时不会对操作数据加锁，只有当数据提交时才会验证数据是否存在并发冲突（版本号对比机制/CAS算法）。乐观锁适用于多读场景（冲突少）（InnoDB mvcc）。
* **悲观锁** 基于一种悲观态度来防止一切的并发冲突，只要操作数据就加锁（排他锁），数据操作后释放锁。悲观锁适用于多写场景（冲突多）
### 4.InnoDB中的锁

****
## 三、并发事务与隔离级别
### 1，并发事务问题
* **脏写** 
* **脏读**
* **不可重复读**
* **幻读**

### 2. 隔离级别
隔离级别指的是，当存在多个事务并发操作相同的数据时，事务之间的相互影响的要求标准。<u>隔离级别是用来解决事务并发带来的问题的，而数据库的锁机制是为了构建这些隔离级别</u>。

数据库事务是增删改查(Insert,Delete,Update,Select)操作的集合，其中Select是读操作，Insert,Update,Delete都是写操作，因此事务并发就是读写并发。

    所有事务单元之间并发关系就是读写、写读、读读、写写四种状态的组合
* **序列化(Serializable)** 
    可串行化是最高等级的隔离级别，事务读写相互阻塞(直接加表级读锁)，所有事务按照次序依次执行，不存在并发。
    可串行化不存在脏读、不可重复读、幻读问题，具有最高的安全性，但是性能最差，一般不会用这种隔离级别。
* **可重复读(Repeated Read)**
    可重复读实现了读读并行（事务对数据加读锁，其他事务只能读，不能写），
    
    假设事务A给目标数据加读锁，直到事务结束，其他事务可以读该数据，但不能改该数据，<u>保证了事务A在事务过程中读到的数据内容总是不变的</u>。但是可重复读只给目标数据加读锁，无法保证锁住其他事务对该数据所在表的操作(insert操作)，仍然存在幻读问题。

* **读已提交(Read Commited)**
    读已提交实现了读读并行，读写并行，写读、写写串行化进行。(事务读数据时加读锁，其他事务既可以读，也可以写(取消读锁))

    假设事务A对目标数据进行读操作，然后事务B对目标数据进行写操作，读写并行，此时事务A<u>取消读锁</u>，允许事务B写操作，就会导致事务A在事务B写之前和写之后读到的数据不一致。因此存在幻读、不可重复读问题。
* **读未提交(Read Uncommited)**
    读未提交是最低等级的隔离级别，实现了读读并行、写读并行、读写并行三种并发事务。事务不加读锁，只加写锁。

    读未提交只有写写串行化，<u>由于不加读锁，所以读的时候会读到没有完成提交的写数据</u>，如果因为一些错误，导致未提交的写操作回滚，就会读到错误数据，因此存在脏读问题。

四种隔离级别区别在于读锁的使用以及锁的粒度，由于都加写锁，实现了基本的写写并行操作，因此都不存在脏写问题。
### 3.三阶段协议（读未提交、读已提交、可重复读隔离级别具体的锁实现）
* 一级封锁协议：事务在修改数据之前必须先对其加写锁，直到事务结束才释放。
    
    可以解决脏写问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）

* 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，<u>读完后释放</u>。

    可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法读取未提交数据，避免了读取脏数据）

* 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，<u>直到事务结束才能释放</u>。

    可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）。

### 4.两段锁协议（序列化具体的实现）
所有的事务必须分两个阶段对数据项加锁和解锁。即事务分两个阶段，第一个阶段是获得锁。事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是释放锁，事务可以释放任何数据项上的任何类型的锁，但不能申请。

第一阶段是获得封锁的阶段，称为扩展阶段：其实也就是该阶段可以进入加锁操作，在对任何数据进行读操作之前要申请获得S锁，在进行写操作之前要申请并获得X锁，加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。就是加锁后就不能解锁了。

第二阶段是释放封锁的阶段，称为收缩阶段：当事务释放一个封锁后，事务进入封锁阶段，在该阶段只能进行解锁而不能再进行加锁操作。


****
## 四、数据库三大日志
[参考资料](https://zhuanlan.zhihu.com/p/401842227)

### redo log
`redo log` 记录了数据库物理层面对数据的修改，是Mysql的**物理日志**。记录了事务对数据页进行了哪些修改，保证了事务四大特性之中的持久性。是InnoDB引擎特有的log

**使用情景**：
* 数据持久化(数据恢复)：

### bin log
`binlog` 记录了数据库执行的所有写入性操作(DML)，以二进制形式保存在磁盘中，是Mysql的**逻辑日志**。是由Mysql `server` 层进行记录，与具体使用的引擎无关。

**使用情景**： 
* 主从复制
* 数据恢复



### undo log
`undo log` 记录了数据库数据修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，保证了事务四大特性之中的原子性，配合记录隐藏字段实现MVCC快照读。




## 四.MySql MVCC
MVCC多版本并发控制。对于读写并发，一般需要通过数据加锁的方式来解决，但是这样会影响并发效率，MVCC就是在读写并发存在的情况下。不加锁实现非阻塞并发读，降低开销，提高数据库并发性能。MVCC只在Read Commited和 Repeatable read两种隔离级别下工作。 

### 定义
* **当前读** ：读取的数据是最新版本，读取数据时还要保证其他并发事务不会修改当前的数据，当前读会对读取的记录加锁。

    `select …… lock in share mode（共享锁）`

    `select …… for update | update | insert | delete（排他锁）`
* **快照读** ：每一次修改数据，都会在 undo log 中存有快照记录，这里的快照，就是读取undo log中的某一版本的快照。这种方式的优点是可以不用加锁就可以读取到数据，缺点是读取到的数据可能不是最新的版本。一般的查询都是快照读。
    
    `select * from t_user where id=1;`

* **事务版本号** 事务每次开启前，都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。
* **隐藏字段** InnoDB存储引擎中每一行记录都有两个隐藏列trx_id,roll_pointer，如果表中没有主键和唯一键时，还会有第三个隐藏的主键列row_id

    |  字段   | 是否必须  |  描述   |
    |  ----  | ----  |  ----  |
    | row_id  | 否 | 单调递增的行ID，不必需，占用6字节  |
    | trx_id  | 是 | 记录操作该数据事务的事务ID  |
    | roll_pointer  | 是 | 指向回滚段undo日志的指针  |

* **版本链** 多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，通过回滚指针可以连成一个链表，这个链表就叫做版本链。


<div style = "text-align: center"><img src = './Image/roll_pointer.png' height="60%" width="60%"></img> </div> 



* **ReadView读视图** 在Innodb中每个SQL语句执行前都会得到一个读视图，读视图主要用来做可见性判断，判断当前事务能够访问哪些版本的数据。


    |  ReadView属性     |  描述   |
    |  ----  |  ----  |
    | m_ids  | 系统中活跃的事务ID，数据结构为List  |
    | min_limit_id  | 生成ReadView时，当前活跃事务的最小id  |
    | max_limit_id  | 生成ReadView时，系统应该分配给下一个事务的id  |
    | creator_trx_id  | 创建ReadView的事务ID  |

    ReadView匹配： 

    (1). 如果数据事务ID trx_id < min_limit_id，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。
    
    (2). 如果trx_id>= max_limit_id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。
    
    (3). 如果 min_limit_id <= trx_id < max_limit_id，需要分3种情况

        如果m_ids包含trx_id且trx_id = creator_trx_id，该事务就是生成ReadView的事务，可访问自己数据。
        如果m_ids包含trx_id且trx_id != creator_trx_id，该事务未提交，且不是自己产生的，不可见。
        如果m_ids不包含trx_id，说明该事务在ReadView之前已提交，可见。

### 实现原理(ReadView + undo log)
基于MVCC的查询：
1. 获取事务自己的版本号，即事务ID；
2. 获取Read View；
3. 查询得到的数据，查看隐藏字段的事务ID trx_id，然后与Read View中的m_ids进行比较，探明可见性；
4. 如果不可见，就通过版本链来寻找undo log中的历史快照；
5. 最后返回符合规则的数据。

MVCC不同隔离级别：
读已提交：事务读操作只使用一次ReadView，事务内共享一个ReadView
可重复读：事务每次读都使用ReadView

幻读：当连续两个快照读中出现当前读，并且当前读有其他事务新增时，会出现幻读。