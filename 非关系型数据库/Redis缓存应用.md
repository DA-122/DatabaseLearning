

## 缓存穿透 - 缓存不起作用
访问一个缓存和数据库都不存在的 key，此时会直接打到数据库上，并且查不到数据，没法写缓存，所以下一次同样会打到数据库上。此时，缓存起不到作用，请求每次都会走到数据库，流量大时数据库可能会被宕机。此时缓存就好像被“穿透”了一样，起不到任何作用。

解决方案：
(1).接口校验：在代码层面做一系列的校验（鉴权、数据合法性），减少非正常key的情况。

(2).缓存空值：如果访问缓存和DB都没有查找到该值，将这个key和空值写入缓存并设置较短的过期时间，就可以直接从缓存中获取空数据了。

(3).布隆过滤器：在缓存与存储之间加一层布隆过滤器。这样能有效减少对数据库的访问。
 
布隆过滤器是一个连续数据结构，每个存储位只存储一个bit(0/1)来标识数据是否存在。存储数据时，使用K个不同的哈希函数将key映射到bit列表中的k个位置，并把他们设为1。
判断缓存是否存在，就将key映射到k个点，判断是否k个点全是1
* 如果全不是1，那么key一定不存在（判定为不存在的一定不存在）；
* 如果全是1，key可能存在，也可能不存在（哈希碰撞）（判定为存在的可能不存在）
* 可以通过k值来调整误判概率，k越大误判率越低。

为什么不用哈希表而用布隆过滤器？因为布隆过滤器比哈希表节省内存空间。

## 缓存击穿
某一个高频key，在缓存过期的一瞬间，有大量请求打了进来。由于缓存过期，会导致数据库瞬时请求量大。

解决方案：
(1).给key加互斥锁，在并发的多个请求中，第一个请求能拿到这个key的锁并进行数据库查询操作，其他请求阻塞等待，直到第一个线程将数据写入缓存，其他请求直接拿走缓存。互斥锁一般使用Redis分布式锁。详情见 [Redis分布式锁](https://zhuanlan.zhihu.com/p/111354065)

(2).热点数据不设置过期，由定时任务去异步加载数据，更新缓存。


## 缓存雪崩
大量的热点 key 设置了相同的过期时间，导在缓存在同一时刻全部失效，造成瞬时数据库请求量大、压力骤增，引起雪崩，甚至导致数据库被打挂。

解决方案：
1. 过期时间打散
2. 热点数据不过期
3. 加互斥锁