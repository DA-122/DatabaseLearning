# 数据库索引
索引是**以数据库表中的一列或者多列值为基础构建起的搜索结构**(按照该列值能找到记录)，能够方便用户按照该列值对表内记录进行搜索。

优点：
* 大大加快了数据检索速度(如果不加索引，那么数据库查询就是全表扫描)；
* 唯一性索引能够保证数据库表数据的唯一性；
* 加速表的连接。

缺点:
* 索引需要占用数据库表之外的物理存储空间(索引存储在硬盘中)；
* 创建和维护索引需要花费一定时间；
* 对表进行更新操作时，索引也需要被重建，降低了数据维护速度。

索引需要考虑的查询操作：

* 等值查询
* 范围查询

# 常见的索引类型（从数据结构看）
按照实现方式分类，常见的索引类型主要有哈希、B-树和有序数组。
## 一、有序数组索引

<div align=center ><img src ="./Image/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95.jpeg"style="zoom:50%"/></div>



有序数组就是按字段值进行顺序存储，在等值查询和范围查询的场景下性能都很优秀。可以通过二分算法进行快速查找，时间复杂的O(log(N))。

但是有序数组的维护成本最高，当有新数据插入或删除时需要移动剩余元素，当有元素修改时，也会产生大量的移动。因此有序数组索引只适用于静态存储引擎，所保存的数据是不会被修改的。

*****

## 二、哈希索引
<div align=center ><img src ="./Image/哈希索引.jpeg"style="zoom:50%"/></div>

哈希索引存储键值对。用哈希进行索引，需要先用哈希函数将key映射成哈希数组中的一个index，然后将对应记录，存放到这个位置。如果多个key哈希之后得到了相同的index，可以用开放寻址法或拉链法（常用）来解决冲突。

哈希索引只能用于等值查询，无法用于范围查询。哈希索引的范围查询实际上就是全表扫描。

哈希表适用于只有等值查询的场景，比如一些NoSQL引擎。
****
## 三、B-树索引(B+树索引)
### **1、B-树**：
B树是一种多叉自平衡树，一个$ m $阶的B树满足如下条件    
* 每个节点最多只有$ m $个子节点（因为至多有$m-1$个元素）;
* 除根之外的每个非叶子节点有至少 $ \lceil m/2 \rceil$个子节点，有 $\lceil m/2 \rceil - 1 $ 到 $m - 1$个元素;
* 具有$ k $个子节点的非叶节点包含$ k - 1 $个键(元素数和子节点数之间的关系)。
* 如果根不是叶节点，则根至少有2个子节点;
* 所有叶子节点又在同一层。

|        | 根节点 |非叶子节点 | 叶子节点 |
|  ----  | ----   | ----   | ----   |
| 子节点下限  | $ 2 $ | $ \lceil m/2 \rceil$  |  $ 0 $   |
| 子节点上限  | $ m $  | $ m $  |  $ 0 $   |
| 元素个数下限 | $ 1 $ | $\lceil m/2 \rceil - 1 $  | $\lceil m/2 \rceil - 1 $  | 单元格 |
| 元素个数上限 | $ m-1 $  | $ m - 1 $  | $ m - 1 $  |

#### **B-树插入**：
针对$m$阶高度$h$的B树，插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素。

* 若该节点元素个数小于$m-1$，直接插入；
* 若该节点元素个数等于$m-1$，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；
* 重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1

#### **B-树删除**：
首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除；删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除。
* 某结点中元素数目小于（m/2）-1,(m/2)向上取整，则需要看其某相邻兄弟结点是否丰满；
* 如果丰满（结点中元素个数大于(m/2)-1），则向父节点借一个元素来满足条件；
* 如果其相邻兄弟都不丰满，即其结点数目等于(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点；


#### **B树理论高度**：
一颗总共有N个关键字的m阶B树的最大高度：$(log_{\frac{m}2} \frac{N+1} 2 )+1$


#### **B树与磁盘IO**：
索引是存储在硬盘中的，因此 $\color{Red}B-树的查询过程就是一个磁盘IO的过程$ B-树的查询过程就是一个磁盘IO的过程，B-树每一层的查询都有一次磁盘IO。在相同数量的总元素个数下，$\color{Red}每个节点的元素个数越多，高度越低，查询所需的I/O次数越少$。

数据库B-树索引每个节点都是一个数据页(MySQL大小为16K),假设每个元素是n Byte类型数据，那么就可以构建一个 16K/nB阶的B-树。B-树能够通过增大节点元素数量有效减少树的高度来减少磁盘IO次数，从而提高查询效率。

*****

### **2、B+树**：
B+树是应文件系统所需而产生的B-树的变体。具有以下特征:
* 有$k$个子树的中间节点包含有$k$个元素，每个元素不保存关键字指针，只用来索引。（B树中是$k-1$个元素，每个元素既保存索引值，又保存关键字指针）
* 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B-树的叶子节点并没有包括全部关键字，根节点、中间节点、叶子节点一起包括了全部的关键字)；
* B+树的叶子节点用链表串接起来，且有序。

#### B+树相比B-树的优势：

* (1).B+树的磁盘读写代价更低： B+树根节点和中间节点不存指针信息，能够读取更多的关键字，IO次数更低。
* (2).B+树查询效率稳定：B+树只有叶子节点才包含关键字指针信息，任何查询都必须查到叶子节点，每次查询的效率相当。
* (3).B+树便于范围查询：B+树范围查找在链表上查找，效率非常高。B树范围查找使用中序遍历（搜索树）

*****

### **3、红黑树**

#### 红黑树和B+树：
红黑树（非严格平衡）插入和删除效率高，但是磁盘IO次数多。如果红黑树在内存中效率会非常高（不用磁盘IO）。B+树严格平衡树，插入删除的效率低，但是树的高度低，所需的磁盘IO次数少。
*****

# MySQL索引类型
## 普通索引
## 唯一性索引
## 主键索引
## 全文索引
## 联合索引